import {
  app,
  autoUpdater,
  BrowserView,
  BrowserWindow,
  clipboard,
  crashReporter,
  dialog,
  globalShortcut,
  ipcMain,
  Menu,
  nativeImage,
  safeStorage,
  screen,
  session,
  shell,
  Tray
} from "electron";
import ElectronStore from "electron-store";
import path from "path";

import MemoryStore from "./memory-store";
import playerStateStore, { PlayerState, VideoState } from "./player-state-store";
import { MemoryStoreSchema, StoreSchema } from "./shared/store/schema";

import CompanionServer from "./integrations/companion-server";
import CustomCSS from "./integrations/custom-css";
import DiscordPresence from "./integrations/discord-presence";
import LastFM from "./integrations/last-fm";
import NowPlayingNotifications from "./integrations/notifications";
import VolumeRatio from "./integrations/volume-ratio";
import log from "electron-log";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const YTM_VIEW_PRELOAD_WEBPACK_ENTRY: string;

let applicationExited = false;
let applicationQuitting = false;
let appUpdateAvailable = false;
let appUpdateDownloaded = false;

let stateSaverInterval: NodeJS.Timeout | null = null;

crashReporter.start({ uploadToServer: false });

log.transports.console.format = "[{processType}][{level}]{text}";
log.transports.file.format = "[{y}-{m}-{d} {h}:{i}:{s}.{ms}][{processType}][{level}]{text}";
log.eventLogger.format = "Electron event {eventSource}#{eventName} observed";

log.initialize({
  preload: true,
  spyRendererConsole: true
});
// Handle logs and errors
log.errorHandler.startCatching({
  showDialog: false,
  onError({ error, processType, versions }) {
    if (applicationExited) return;
    if (processType === "renderer") return;

    if (stateSaverInterval) clearInterval(stateSaverInterval);

    log.error(error);

    let result = 1; // Default to Exit

    const dialogMessage =
      `Environment Details:\n    ${versions.app}\n    ${versions.electron}\n    ${versions.os}\n\n` +
      `Name: ${error.name}\nMessage: ${error.message}\nCause: ${error.cause ?? "Unknown"}\n\n` +
      `${error.stack}`;

    if (!app.isReady()) {
      dialog.showErrorBox(`YouTube Music Desktop App Crashed`, `Application crashed before ready\n\n${dialogMessage}`);
    } else {
      const options = ["Copy to Clipboard and Exit", "Exit"];
      if (!app.isPackaged) {
        options.push("Copy to Clipboard and Continue", "Continue");
      }

      result = dialog.showMessageBoxSync({
        title: "Error",
        message: "YouTube Music Desktop App Crashed",
        detail: dialogMessage,
        type: "error",
        buttons: options
      });

      // Copy to Clipboard
      if (result === 0 || result === 2) {
        clipboard.writeText(`YouTube Music Desktop App Crashed\n\n${dialogMessage}`);
      }
    }

    // Exit
    if (result === 0 || result === 1) {
      applicationExited = true;
      app.exit(1);
    }
  }
});
log.eventLogger.startLogging();

Object.assign(console, log.functions);

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  applicationQuitting = true;
  app.quit();
}

log.info("Application launched");

const companionServer = new CompanionServer();
const customCss = new CustomCSS();
const discordPresence = new DiscordPresence();
const lastFMScrobbler = new LastFM();
const nowPlayingNotifications = new NowPlayingNotifications();
const ratioVolume = new VolumeRatio();

let mainWindow: BrowserWindow = null;
let settingsWindow: BrowserWindow = null;
let ytmView: BrowserView = null;
let tray = null;
let trayContextMenu = null;

// These variables tend to be changed often so we store it in memory and write on close (less disk usage)
let lastUrl = "";
let lastVideoId = "";
let lastPlaylistId = "";

let companionAuthWindowEnableTimeout: NodeJS.Timeout | null = null;

// Single Instances Lock
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.exit(0);
} else {
  app.on("second-instance", (_, commandLine) => {
    if (mainWindow) {
      mainWindow.show();
      if (mainWindow.isMinimized()) {
        mainWindow.restore();
      }
      mainWindow.focus();
    }

    handleProtocol(commandLine[commandLine.length - 1]);
  });
}

// Protocol handler
function handleProtocol(url: string) {
  log.info("Handling protocol url", url);
  const urlPaths = url.split("://")[1];
  if (urlPaths) {
    const paths = urlPaths.split("/");
    if (paths.length > 0) {
      switch (paths[0]) {
        case "play": {
          if (paths.length >= 2) {
            const videoId = paths[1];
            const playlistId = paths[2];

            if (ytmView) {
              ytmView.webContents.send("remoteControl:execute", "navigate", {
                watchEndpoint: {
                  videoId: videoId,
                  playlistId: playlistId
                }
              });
            }
          }
        }
      }
    }
  }
}

// This will register the protocol in development, this is intentional and should stay this way for development purposes
if (!app.isDefaultProtocolClient("ytmd")) {
  if (process.defaultApp) {
    if (process.argv.length >= 2) {
      log.info("Application set as default protcol client for 'ytmd'");
      app.setAsDefaultProtocolClient("ytmd", process.execPath, [path.resolve(process.argv[1])]);
    }
  } else {
    log.info("Application set as default protcol client for 'ytmd'");
    app.setAsDefaultProtocolClient("ytmd", process.execPath);
  }
}

// Create the in-memory store for state within the UI
const memoryStore = new MemoryStore<MemoryStoreSchema>();
memoryStore.onStateChanged((newState, oldState) => {
  if (settingsWindow !== null) {
    settingsWindow.webContents.send("memoryStore:stateChanged", newState, oldState);
  }

  if (ytmView !== null) {
    ytmView.webContents.send("memoryStore:stateChanged", newState, oldState);
  }
});
log.info("Created memory store");

// Configure the autoupdater
// macOS cannot use the autoUpdater without a code signature at this time
if (process.platform !== "darwin") {
  const updateServer = "https://update.electronjs.org";
  const updateFeed = `${updateServer}/ytmdesktop/ytmdesktop/${process.platform}-${process.arch}/${app.getVersion()}`;

  autoUpdater.setFeedURL({
    url: updateFeed
  });
  autoUpdater.on("checking-for-update", () => {
    if (settingsWindow) {
      settingsWindow.webContents.send("app:checkingForUpdates");
    }
  });
  autoUpdater.on("update-available", () => {
    log.info("Application update available");
    appUpdateAvailable = true;
    if (settingsWindow) {
      settingsWindow.webContents.send("app:updateAvailable");
    }
  });
  autoUpdater.on("update-not-available", () => {
    if (settingsWindow) {
      settingsWindow.webContents.send("app:updateNotAvailable");
    }
  });
  autoUpdater.on("update-downloaded", () => {
    log.info("Application update downloaded");
    appUpdateDownloaded = true;
    if (settingsWindow) {
      settingsWindow.webContents.send("app:updateDownloaded");
    }
  });
  log.info("Setup application updater");
  /*
  TEMPORARY UPDATE CHECK DISABLE WHILE DEVELOPMENT OCCURS (This will always have errors for now until a release occurs)
  setInterval(() => {
    autoUpdater.checkForUpdates()
  }, 1000 * 60 * 10);
  */
} else {
  memoryStore.set("autoUpdaterDisabled", true);
}

// Create the persistent config store
const store = new ElectronStore<StoreSchema>({
  watch: true,
  defaults: {
    metadata: {
      version: 1
    },
    general: {
      hideToTrayOnClose: false,
      showNotificationOnSongChange: false,
      startOnBoot: false,
      startMinimized: false,
      disableHardwareAcceleration: false
    },
    appearance: {
      alwaysShowVolumeSlider: false,
      customCSSEnabled: false,
      customCSSPath: null
    },
    playback: {
      continueWhereYouLeftOff: true,
      continueWhereYouLeftOffPaused: true,
      progressInTaskbar: false,
      enableSpeakerFill: false,
      ratioVolume: false
    },
    integrations: {
      companionServerEnabled: false,
      companionServerAuthTokens: null,
      companionServerCORSWildcardEnabled: false,
      discordPresenceEnabled: false,
      lastFMEnabled: false
    },
    shortcuts: {
      playPause: "",
      next: "",
      previous: "",
      thumbsUp: "",
      thumbsDown: "",
      volumeUp: "",
      volumeDown: ""
    },
    state: {
      lastUrl: "https://music.youtube.com/",
      lastVideoId: "",
      lastPlaylistId: "",
      windowBounds: null,
      windowMaximized: false
    },
    lastfm: {
      api_key: "2a69bcf769a7a28a8bf2f6a5100accad",
      secret: "46eea23770a459a49eb4d26cbf46b41c",
      token: null,
      sessionKey: null
    },
    developer: {
      enableDevTools: false
    }
  },
  beforeEachMigration: (store, context) => {
    log.info(`Performing store migration from ${context.fromVersion} to ${context.toVersion}`);
  },
  migrations: {
    ">=2.0.0-rc.2": store => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      store.delete("integrations.companionServerAuthWindowEnabled");
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      store.delete("state.companionServerAuthWindowEnableTime");
    }
  }
});
store.onDidAnyChange(async (newState, oldState) => {
  if (settingsWindow !== null) {
    settingsWindow.webContents.send("settings:stateChanged", newState, oldState);
  }

  if (ytmView !== null) {
    ytmView.webContents.send("settings:stateChanged", newState, oldState);
  }

  // Setting start on boot in development tends to cause a blank electron executable to start on boot so let's never set that
  if (process.env.NODE_ENV !== "development") {
    app.setLoginItemSettings({
      openAtLogin: newState.general.startOnBoot
    });
  }

  if (newState.general.showNotificationOnSongChange) {
    nowPlayingNotifications.enable();
    log.info("Integration enabled: Now playing notifications");
  } else if (!newState.general.showNotificationOnSongChange && oldState.general.showNotificationOnSongChange) {
    nowPlayingNotifications.disable();
    log.info("Integration disabled: Now playing notifications");
  }

  if (newState.appearance.customCSSEnabled) {
    customCss.provide(store, ytmView);
  }
  if (newState.appearance.customCSSEnabled && !oldState.appearance.customCSSEnabled) {
    customCss.enable();
    log.info("Integration enabled: Custom CSS");
  } else if (!newState.appearance.customCSSEnabled && oldState.appearance.customCSSEnabled) {
    customCss.disable();
    log.info("Integration disabled: Custom CSS");
  }

  if (newState.playback.ratioVolume) {
    ratioVolume.provide(ytmView);
  }
  if (newState.playback.ratioVolume && !oldState.playback.ratioVolume) {
    ratioVolume.enable();
    log.info("Integration enabled: Ratio volume");
  } else if (!newState.playback.ratioVolume && oldState.playback.ratioVolume) {
    ratioVolume.disable();
    log.info("Integration disabled: Ratio volume");
  }

  let companionServerAuthWindowEnabled = memoryStore.get("companionServerAuthWindowEnabled") ?? false;

  if (newState.integrations.companionServerEnabled) {
    companionServer.provide(store, memoryStore, ytmView);
  }
  if (newState.integrations.companionServerEnabled && !oldState.integrations.companionServerEnabled) {
    companionServer.enable();
    log.info("Integration enabled: Companion server");
  } else if (!newState.integrations.companionServerEnabled && oldState.integrations.companionServerEnabled) {
    companionServer.disable();
    log.info("Integration disabled: Companion server");

    if (companionServerAuthWindowEnabled) {
      memoryStore.set("companionServerAuthWindowEnabled", false);
      clearInterval(companionAuthWindowEnableTimeout);
      companionAuthWindowEnableTimeout = null;
      companionServerAuthWindowEnabled = false;
    }
  }

  if (companionServerAuthWindowEnabled) {
    if (!companionAuthWindowEnableTimeout) {
      companionAuthWindowEnableTimeout = setTimeout(() => {
        memoryStore.set("companionServerAuthWindowEnabled", null);
        companionAuthWindowEnableTimeout = null;
      }, 300 * 1000);
    }
  }

  if (newState.integrations.companionServerCORSWildcardEnabled && !oldState.integrations.companionServerCORSWildcardEnabled) {
    // Check if the companion server has been enabled and needs a restart from CORS wildcard change
    if (newState.integrations.companionServerEnabled && oldState.integrations.companionServerEnabled) {
      await companionServer.disable();
      await companionServer.enable();
    }
  } else if (!newState.integrations.companionServerCORSWildcardEnabled && oldState.integrations.companionServerCORSWildcardEnabled) {
    // Check if the companion server has been disabled and needs a restart from CORS wildcard change
    if (newState.integrations.companionServerEnabled && oldState.integrations.companionServerEnabled) {
      await companionServer.disable();
      await companionServer.enable();
    }
  }

  if (newState.integrations.discordPresenceEnabled) {
    discordPresence.provide(memoryStore);
  }
  if (newState.integrations.discordPresenceEnabled && !oldState.integrations.discordPresenceEnabled) {
    discordPresence.enable();
    log.info("Integration enabled: Discord presence");
  } else if (!newState.integrations.discordPresenceEnabled && oldState.integrations.discordPresenceEnabled) {
    discordPresence.disable();
    log.info("Integration disabled: Discord presence");
  }

  if (newState.integrations.lastFMEnabled) {
    lastFMScrobbler.provide(store, memoryStore);
  }
  if (newState.integrations.lastFMEnabled && !oldState.integrations.lastFMEnabled) {
    lastFMScrobbler.enable();
    log.info("Integration enabled: Last.fm");
  } else if (!newState.integrations.lastFMEnabled && oldState.integrations.lastFMEnabled) {
    lastFMScrobbler.disable();
    log.info("Integration disabled: Last.fm");
  }

  registerShortcuts();
});
log.info("Created electron store");

if (store.get("general").disableHardwareAcceleration) {
  app.disableHardwareAcceleration();
}

if (store.get("playback").enableSpeakerFill) {
  app.commandLine.appendSwitch("try-supported-channel-layouts");
}

function saveState() {
  store.set("state.lastUrl", lastUrl);
  store.set("state.lastVideoId", lastVideoId);
  store.set("state.lastPlaylistId", lastPlaylistId);
}

// Automatic background state saving every 5 minutes
stateSaverInterval = setInterval(() => {
  saveState();
}, 5 * 60 * 1000);

function setupTaskbarFeatures() {
  // Setup Taskbar Icons
  const assetFolder = path.join(process.env.NODE_ENV === "development" ? path.join(app.getAppPath(), "src/assets") : process.resourcesPath);
  if (mainWindow && mainWindow.isVisible() && process.platform === "win32") {
    mainWindow.setThumbarButtons([
      {
        tooltip: "Previous",
        icon: nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-previous-button.png")),
        flags: ["disabled"],
        click() {
          if (ytmView) {
            ytmView.webContents.send("remoteControl:execute", "previous");
          }
        }
      },
      {
        tooltip: "Play/Pause",
        icon: nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-button.png")),
        flags: ["disabled"],
        click() {
          if (ytmView) {
            ytmView.webContents.send("remoteControl:execute", "playPause");
          }
        }
      },
      {
        tooltip: "Next",
        icon: nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-next-button.png")),
        flags: ["disabled"],
        click() {
          if (ytmView) {
            ytmView.webContents.send("remoteControl:execute", "next");
          }
        }
      }
    ]);
  }
  playerStateStore.addEventListener((state: PlayerState) => {
    const hasVideo = !!state.videoDetails;
    const isPlaying = state.trackState === VideoState.Playing;

    if (process.platform == "win32") {
      const taskbarFlags = [];
      if (!hasVideo) {
        taskbarFlags.push("disabled");
      }

      if (mainWindow && mainWindow.isVisible()) {
        mainWindow.setThumbarButtons([
          {
            tooltip: "Previous",
            icon: nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-previous-button.png")),
            flags: taskbarFlags,
            click() {
              if (ytmView) {
                ytmView.webContents.send("remoteControl:execute", "previous");
              }
            }
          },
          {
            tooltip: "Play/Pause",
            icon: isPlaying
              ? nativeImage.createFromPath(path.join(assetFolder, "icons/controls/pause-button.png"))
              : nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-button.png")),
            flags: taskbarFlags,
            click() {
              if (ytmView) {
                ytmView.webContents.send("remoteControl:execute", "playPause");
              }
            }
          },
          {
            tooltip: "Next",
            icon: nativeImage.createFromPath(path.join(assetFolder, "icons/controls/play-next-button.png")),
            flags: taskbarFlags,
            click() {
              if (ytmView) {
                ytmView.webContents.send("remoteControl:execute", "next");
              }
            }
          }
        ]);
      }
    }

    if (mainWindow && store.get("playback.progressInTaskbar")) {
      mainWindow.setProgressBar(hasVideo ? state.videoProgress / state.videoDetails.durationSeconds : -1, {
        mode: isPlaying ? "normal" : "paused"
      });
    }
  });

  store.onDidChange("playback", (newValue, oldValue) => {
    if (mainWindow && newValue.progressInTaskbar !== oldValue.progressInTaskbar && !newValue.progressInTaskbar) {
      mainWindow.setProgressBar(-1);
    }
  });
}

// Shortcut registration
function registerShortcuts() {
  const shortcuts = store.get("shortcuts");

  globalShortcut.unregisterAll();
  log.info("Unregistered shortcuts");

  if (shortcuts.playPause) {
    const registered = globalShortcut.register(shortcuts.playPause, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "playPause");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: playPause");
      memoryStore.set("shortcutsPlayPauseRegisterFailed", true);
    } else {
      log.info("Registered shortcut: playPause");
      memoryStore.set("shortcutsPlayPauseRegisterFailed", false);
    }
  }

  if (shortcuts.next) {
    const registered = globalShortcut.register(shortcuts.next, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "next");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: next");
      memoryStore.set("shortcutsNextRegisterFailed", true);
    } else {
      log.info("Registered shortcut: next");
      memoryStore.set("shortcutsNextRegisterFailed", false);
    }
  }

  if (shortcuts.previous) {
    const registered = globalShortcut.register(shortcuts.previous, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "previous");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: previous");
      memoryStore.set("shortcutsPreviousRegisterFailed", true);
    } else {
      log.info("Registered shortcut: previous");
      memoryStore.set("shortcutsPreviousRegisterFailed", false);
    }
  }

  if (shortcuts.thumbsUp) {
    const registered = globalShortcut.register(shortcuts.thumbsUp, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "thumbsUp");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: thumbsUp");
      memoryStore.set("shortcutsThumbsUpRegisterFailed", true);
    } else {
      log.info("Registered shortcut: thumbsUp");
      memoryStore.set("shortcutsThumbsUpRegisterFailed", false);
    }
  }

  if (shortcuts.thumbsDown) {
    const registered = globalShortcut.register(shortcuts.thumbsDown, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "thumbsDown");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: thumbsDown");
      memoryStore.set("shortcutsThumbsDownRegisterFailed", true);
    } else {
      log.info("Registered shortcut: thumbsDown");
      memoryStore.set("shortcutsThumbsDownRegisterFailed", false);
    }
  }

  if (shortcuts.volumeUp) {
    const registered = globalShortcut.register(shortcuts.volumeUp, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "volumeUp");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: volumeUp");
      memoryStore.set("shortcutsVolumeUpRegisterFailed", true);
    } else {
      log.info("Registered shortcut: volumeUp");
      memoryStore.set("shortcutsVolumeUpRegisterFailed", false);
    }
  }

  if (shortcuts.volumeDown) {
    const registered = globalShortcut.register(shortcuts.volumeDown, () => {
      if (ytmView) {
        ytmView.webContents.send("remoteControl:execute", "volumeDown");
      }
    });

    if (!registered) {
      log.info("Failed to register shortcut: volumeDown");
      memoryStore.set("shortcutsVolumeDownRegisterFailed", true);
    } else {
      log.info("Registered shortcut: volumeDown");
      memoryStore.set("shortcutsVolumeDownRegisterFailed", false);
    }
  }

  log.info("Registered shortcuts");
}

// Functions which call to mainWindow renderer
function sendMainWindowStateIpc() {
  if (mainWindow !== null) {
    mainWindow.webContents.send("mainWindow:stateChanged", {
      minimized: mainWindow.isMinimized(),
      maximized: mainWindow.isMaximized(),
      fullscreen: mainWindow.isFullScreen()
    });
  }
}

// Functions with call to ytmView renderer
function ytmViewNavigated() {
  if (ytmView !== null) {
    const url = ytmView.webContents.getURL();
    if (url.startsWith("https://music.youtube.com/")) {
      lastUrl = ytmView.webContents.getURL();
      ytmView.webContents.send("ytmView:navigationStateChanged", {
        canGoBack: ytmView.webContents.canGoBack(),
        canGoForward: ytmView.webContents.canGoForward()
      });
    }
  }
}

// Functions which call to settingsWindow renderer
function sendSettingsWindowStateIpc() {
  if (settingsWindow !== null) {
    settingsWindow.webContents.send("settingsWindow:stateChanged", {
      minimized: settingsWindow.isMinimized(),
      maximized: settingsWindow.isMaximized()
    });
  }
}

// Handles any navigation or window opening from ytmView
function openExternalFromYtmView(urlString: string) {
  const url = new URL(urlString);
  const domainSplit = url.hostname.split(".");
  domainSplit.reverse();
  const domain = `${domainSplit[1]}.${domainSplit[0]}`;
  if (domain === "google.com" || domain === "youtube.com") {
    shell.openExternal(urlString);
  }
}

const createOrShowSettingsWindow = (): void => {
  if (mainWindow === null) {
    return;
  }

  if (settingsWindow !== null) {
    settingsWindow.focus();
    return;
  }

  const mainWindowBounds = mainWindow.getBounds();

  // Create the browser window.
  settingsWindow = new BrowserWindow({
    width: 800,
    height: 600,
    x: Math.round(mainWindowBounds.x + (mainWindowBounds.width / 2 - 400)),
    y: Math.round(mainWindowBounds.y + (mainWindowBounds.height / 2 - 300)),
    minimizable: false,
    maximizable: false,
    resizable: false,
    frame: false,
    show: false,
    parent: mainWindow,
    modal: process.platform !== "darwin",
    titleBarStyle: "hidden",
    titleBarOverlay: {
      color: "#000000",
      symbolColor: "#BBBBBB",
      height: 36
    },
    webPreferences: {
      sandbox: true,
      contextIsolation: true,
      preload: SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: store.get("developer.enableDevTools")
    }
  });

  // Attach events to settings window
  settingsWindow.on("maximize", sendSettingsWindowStateIpc);
  settingsWindow.on("unmaximize", sendSettingsWindowStateIpc);
  settingsWindow.on("minimize", sendSettingsWindowStateIpc);
  settingsWindow.on("restore", sendSettingsWindowStateIpc);

  settingsWindow.once("closed", () => {
    settingsWindow = null;
  });

  settingsWindow.webContents.setWindowOpenHandler(details => {
    if (details.url === "https://github.com/ytmdesktop/ytmdesktop" || details.url === "https://ytmdesktop.app/") {
      shell.openExternal(details.url);
    }

    return {
      action: "deny"
    };
  });

  settingsWindow.webContents.on("will-navigate", event => {
    if (process.env.NODE_ENV === "development") if (event.url.startsWith("http://localhost")) return;

    event.preventDefault();
  });

  settingsWindow.on("ready-to-show", () => {
    settingsWindow.show();
    // Open the DevTools.
    if (process.env.NODE_ENV === "development") {
      settingsWindow.webContents.openDevTools({
        mode: "detach"
      });
    }
  });

  // and load the index.html of the app.
  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);
};

const createYTMView = (): void => {
  ytmView = new BrowserView({
    webPreferences: {
      sandbox: true,
      contextIsolation: true,
      partition: "persist:ytmview",
      preload: YTM_VIEW_PRELOAD_WEBPACK_ENTRY,
      autoplayPolicy: store.get("playback.continueWhereYouLeftOffPaused") ? "document-user-activation-required" : "no-user-gesture-required"
    }
  });
  companionServer.provide(store, memoryStore, ytmView);
  customCss.provide(store, ytmView);
  ratioVolume.provide(ytmView);

  let navigateDefault = true;

  const continueWhereYouLeftOff: boolean = store.get("playback.continueWhereYouLeftOff");
  if (continueWhereYouLeftOff) {
    const lastUrl: string = store.get("state.lastUrl");
    if (lastUrl) {
      if (lastUrl.startsWith("https://music.youtube.com/")) {
        ytmView.webContents.loadURL(lastUrl);
        navigateDefault = false;
      }
    }
  }

  if (navigateDefault) {
    ytmView.webContents.loadURL("https://music.youtube.com/");
    store.set("state.lastUrl", "https://music.youtube.com/");
  }

  // Attach events to ytm view
  ytmView.webContents.on("will-navigate", event => {
    if (
      !event.url.startsWith("https://consent.youtube.com/") &&
      !event.url.startsWith("https://accounts.google.com/") &&
      !event.url.startsWith("https://accounts.youtube.com/") &&
      !event.url.startsWith("https://music.youtube.com/") &&
      !event.url.startsWith("https://www.youtube.com/signin")
    ) {
      event.preventDefault();

      openExternalFromYtmView(event.url);
    }
  });
  ytmView.webContents.on("did-navigate", ytmViewNavigated);
  ytmView.webContents.on("did-navigate-in-page", ytmViewNavigated);
  ytmView.webContents.on("enter-html-full-screen", () => {
    if (mainWindow) {
      mainWindow.setFullScreen(true);
    }
  });
  ytmView.webContents.on("leave-html-full-screen", () => {
    if (mainWindow) {
      mainWindow.setFullScreen(false);
    }
  });
  ytmView.webContents.on("render-process-gone", () => {
    store.set("state.lastUrl", lastUrl);
    store.set("state.lastVideoId", lastVideoId);
    store.set("state.lastPlaylistId", lastPlaylistId);
    createYTMView();
  });

  ytmView.webContents.on('will-prevent-unload', (event) => {
    if (mainWindow) {
      if (ytmView.webContents.getURL().startsWith("https://music.youtube.com/")) {
        const choice = dialog.showMessageBoxSync(mainWindow, {
          type: 'question',
          buttons: ['Leave', 'Stay'],
          title: 'Navigation',
          message: 'YouTube Music is preventing navigation. Do you want to leave or stay?',
          defaultId: 0,
          cancelId: 1
        })

        if (choice !== 0) {
          return;
        }
      }
    }

    event.preventDefault();
  })

  ytmView.webContents.setWindowOpenHandler(details => {
    openExternalFromYtmView(details.url);

    return {
      action: "deny"
    };
  });
};

const createMainWindow = (): void => {
  // Create the browser window.
  const scaleFactor = screen.getPrimaryDisplay().scaleFactor;
  const windowBounds = store.get("state").windowBounds;
  mainWindow = new BrowserWindow({
    width: windowBounds?.width ?? 1280 / scaleFactor,
    height: windowBounds?.height ?? 720 / scaleFactor,
    x: windowBounds?.x,
    y: windowBounds?.y,
    frame: false,
    show: false,
    icon: "./assets/icons/ytmd.png",
    titleBarStyle: "hidden",
    titleBarOverlay: {
      color: "#000000",
      symbolColor: "#BBBBBB",
      height: 36
    },
    webPreferences: {
      sandbox: true,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: store.get("developer.enableDevTools")
    }
  });
  const windowMaximized = store.get("state").windowMaximized;
  // Even though bounds are set when creating the main window we set the bounds again to fix scaling issues. This is classified as an upstream chromium bug.
  if (windowBounds) {
    mainWindow.setBounds(windowBounds);
  }
  if (windowMaximized) {
    mainWindow.maximize();
  }

  // Create the YouTube Music view
  createYTMView();
  log.info("Created YTM view");

  // Attach events to main window
  mainWindow.on("resize", () => {
    setTimeout(() => {
      if (ytmView) {
        if (mainWindow.fullScreen) {
          ytmView.setBounds({
            x: 0,
            y: 0,
            width: mainWindow.getContentBounds().width,
            height: mainWindow.getContentBounds().height
          });
        } else {
          ytmView.setBounds({
            x: 0,
            y: 36,
            width: mainWindow.getContentBounds().width,
            height: mainWindow.getContentBounds().height - 36
          });
        }
      }
    });
  });

  mainWindow.on("enter-full-screen", () => {
    setTimeout(() => {
      if (ytmView) {
        ytmView.setBounds({
          x: 0,
          y: 0,
          width: mainWindow.getContentBounds().width,
          height: mainWindow.getContentBounds().height
        });
      }
    });
    sendMainWindowStateIpc();
  });
  mainWindow.on("leave-full-screen", () => {
    setTimeout(() => {
      ytmView.setBounds({
        x: 0,
        y: 36,
        width: mainWindow.getContentBounds().width,
        height: mainWindow.getContentBounds().height - 36
      });
    });
    sendMainWindowStateIpc();
  });
  mainWindow.on("maximize", sendMainWindowStateIpc);
  mainWindow.on("unmaximize", sendMainWindowStateIpc);
  mainWindow.on("minimize", sendMainWindowStateIpc);
  mainWindow.on("restore", sendMainWindowStateIpc);
  mainWindow.on("close", event => {
    if (!applicationQuitting && (store.get("general").hideToTrayOnClose || process.platform === "darwin")) {
      event.preventDefault();
      mainWindow.hide();
    }

    store.set("state.windowBounds", mainWindow.getNormalBounds());
    store.set("state.windowMaximized", mainWindow.isMaximized());
  });

  mainWindow.once("closed", () => {
    mainWindow = null;
  });

  mainWindow.webContents.setWindowOpenHandler(() => {
    return {
      action: "deny"
    };
  });

  mainWindow.webContents.on("will-navigate", event => {
    if (process.env.NODE_ENV === "development") if (event.url.startsWith("http://localhost")) return;

    event.preventDefault();
  });

  mainWindow.on("ready-to-show", () => {
    mainWindow.show();
    // Open the DevTools.
    if (process.env.NODE_ENV === "development") {
      mainWindow.webContents.openDevTools({
        mode: "detach"
      });
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
  log.info("Application ready");

  if (!safeStorage.isEncryptionAvailable()) {
    memoryStore.set("safeStorageAvailable", false);
  } else {
    memoryStore.set("safeStorageAvailable", true);
  }

  // Handle main window ipc
  ipcMain.on("mainWindow:minimize", () => {
    if (mainWindow !== null) {
      mainWindow.minimize();
    }
  });

  ipcMain.on("mainWindow:maximize", () => {
    if (mainWindow !== null) {
      mainWindow.maximize();
    }
  });

  ipcMain.on("mainWindow:restore", () => {
    if (mainWindow !== null) {
      mainWindow.restore();
    }
  });

  ipcMain.on("mainWindow:close", () => {
    if (mainWindow !== null) {
      if (store.get("general").hideToTrayOnClose || process.platform === "darwin") {
        mainWindow.hide();
      } else {
        applicationQuitting = true;
        app.quit();
      }
    }
  });

  ipcMain.on("mainWindow:requestWindowState", () => {
    sendMainWindowStateIpc();
  });

  // Handle settings window ipc
  ipcMain.on("settingsWindow:open", () => {
    createOrShowSettingsWindow();
  });

  ipcMain.on("settingsWindow:minimize", () => {
    if (settingsWindow !== null) {
      settingsWindow.minimize();
    }
  });

  ipcMain.on("settingsWindow:maximize", () => {
    if (settingsWindow !== null) {
      settingsWindow.maximize();
    }
  });

  ipcMain.on("settingsWindow:restore", () => {
    if (settingsWindow !== null) {
      settingsWindow.restore();
    }
  });

  ipcMain.on("settingsWindow:close", () => {
    if (settingsWindow !== null) {
      settingsWindow.close();
    }
  });

  ipcMain.on("settingsWindow:restartapplication", () => {
    app.relaunch();
    applicationQuitting = true;
    app.quit();
  });

  ipcMain.on("settingsWindow:restartApplicationForUpdate", () => {
    applicationQuitting = true;
    autoUpdater.quitAndInstall();
  });

  // Handle ytm view ipc
  ipcMain.on("ytmView:loaded", () => {
    if (ytmView !== null && mainWindow !== null) {
      mainWindow.addBrowserView(ytmView);
      ytmView.setBounds({
        x: 0,
        y: 36,
        width: mainWindow.getContentBounds().width,
        height: mainWindow.getContentBounds().height - 36
      });
      if (process.env.NODE_ENV === "development") {
        ytmView.webContents.openDevTools({
          mode: "detach"
        });
      }
    }
  });

  ipcMain.on("ytmView:videoProgressChanged", (event, progress) => {
    playerStateStore.updateVideoProgress(progress);
  });

  ipcMain.on("ytmView:videoStateChanged", (event, state) => {
    // ytm state mapping definitions
    // -1 -> Unknown (Seems tied to no buffer data, but cannot confirm)
    // 1 -> Playing
    // 2 -> Paused
    // 3 -> Buffering
    // 5 -> Unknown (Only happens when loading new songs - unsure what this is for)

    // ytm state flow
    // Play Button Click
    //   -1 -> 5 -> -1 -> 3 -> 1
    // First Play Button Click (Only happens when the player is first loaded)
    //   -1 -> 3 -> 1
    // Previous/Next Song Click
    //   -1 -> 5 -> -1 -> 5 -> -1 -> 3 -> 1

    playerStateStore.updateVideoState(state);
  });

  ipcMain.on("ytmView:videoDataChanged", (event, videoDetails, playlistId) => {
    lastVideoId = videoDetails.videoId;
    lastPlaylistId = playlistId;

    playerStateStore.updateVideoDetails(videoDetails, playlistId);
  });

  ipcMain.on("ytmView:storeStateChanged", (event, queue) => {
    playerStateStore.updateQueue(queue);
  });

  ipcMain.on("ytmView:switchFocus", (event, context) => {
    if (context === "main") {
      if (mainWindow && ytmView.webContents.isFocused()) {
        mainWindow.webContents.focus();
      }
    } else if (context === "ytm") {
      if (ytmView && mainWindow.webContents.isFocused()) {
        ytmView.webContents.focus();
      }
    }
  });

  ipcMain.on("ytmView:navigateDefault", () => {
    if (ytmView) {
      ytmView.webContents.loadURL("https://music.youtube.com/");
    }
  })

  // Handle memory store ipc
  ipcMain.on("memoryStore:set", (event, key: string, value?: string) => {
    memoryStore.set(key, value);
  });

  ipcMain.handle("memoryStore:get", (event, key: string) => {
    return memoryStore.get(key);
  });

  // Handle settings store ipc
  ipcMain.on("settings:set", (event, key: string, value?: string) => {
    store.set(key, value);
  });

  ipcMain.handle("settings:get", (event, key: string) => {
    return store.get(key);
  });

  ipcMain.handle("settings:reset", (event, key: keyof StoreSchema) => {
    store.reset(key);
  });

  // Handle safeStorage ipc
  ipcMain.handle("safeStorage:decryptString", (event, value: string) => {
    if (!memoryStore.get("safeStorageAvailable")) throw new Error("safeStorage is unavailable");

    if (value) {
      return safeStorage.decryptString(Buffer.from(value, "hex"));
    } else {
      return null;
    }
  });

  ipcMain.handle("safeStorage:encryptString", (event, value: string) => {
    if (!memoryStore.get("safeStorageAvailable")) throw new Error("safeStorage is unavailable");
    return safeStorage.encryptString(value).toString("hex");
  });

  // Handle app ipc
  ipcMain.handle("app:getVersion", () => {
    return app.getVersion();
  });

  ipcMain.on("app:checkForUpdates", () => {
    // autoUpdater downloads automatically and calling checkForUpdates causes duplicate install
    if (!appUpdateAvailable || !appUpdateDownloaded) {
      autoUpdater.checkForUpdates();
    }
  });

  ipcMain.handle("app:isUpdateAvailable", () => {
    return appUpdateAvailable;
  });

  ipcMain.handle("app:isUpdateDownloaded", () => {
    return appUpdateDownloaded;
  });

  log.info("Setup IPC handlers");

  // Create the permission handlers
  session.fromPartition("persist:ytmview").setPermissionCheckHandler((webContents, permission) => {
    if (webContents == ytmView.webContents) {
      if (permission === "fullscreen") {
        return true;
      }
    }

    return false;
  });
  session.fromPartition("persist:ytmview").setPermissionRequestHandler((webContents, permission, callback) => {
    if (webContents == ytmView.webContents) {
      if (permission === "fullscreen") {
        return callback(true);
      }
    }

    return callback(false);
  });

  log.info("Setup permission handlers");

  // Register global shortcuts
  registerShortcuts();

  // Create the tray
  tray = new Tray(
    path.join(
      process.env.NODE_ENV === "development" ? path.join(app.getAppPath(), "src/assets") : process.resourcesPath,
      process.platform === "win32" ? "icons/tray.ico" : "icons/trayTemplate.png"
    )
  );
  trayContextMenu = Menu.buildFromTemplate([
    {
      label: "YouTube Music Desktop",
      type: "normal",
      enabled: false
    },
    {
      type: "separator"
    },
    {
      label: "Show/Hide Window",
      type: "normal",
      click: () => {
        if (mainWindow) {
          if (mainWindow.isVisible()) {
            mainWindow.hide();
          } else {
            mainWindow.show();
          }
        }
      }
    },
    {
      label: "Play/Pause",
      type: "normal",
      click: () => {
        ytmView.webContents.send("remoteControl:execute", "playPause");
      }
    },
    {
      label: "Previous",
      type: "normal",
      click: () => {
        ytmView.webContents.send("remoteControl:execute", "previous");
      }
    },
    {
      label: "Next",
      type: "normal",
      click: () => {
        ytmView.webContents.send("remoteControl:execute", "next");
      }
    },
    {
      type: "separator"
    },
    {
      label: "Quit",
      type: "normal",
      click: () => {
        applicationQuitting = true;
        app.quit();
      }
    }
  ]);
  tray.setToolTip("YouTube Music Desktop");
  tray.setContextMenu(trayContextMenu);
  tray.on("click", () => {
    if (mainWindow) {
      mainWindow.show();
    }
  });

  log.info("Created tray icon");

  createMainWindow();
  log.info("Created main window");

  // Setup taskbar features
  setupTaskbarFeatures();
  log.info("Setup taskbar features");

  // Integrations setup
  log.info("Starting enabled integrations");

  // LastFM
  if (store.get("integrations").lastFMEnabled) {
    lastFMScrobbler.provide(store, memoryStore);
    lastFMScrobbler.enable();
    log.info("Integration enabled: Last.fm");
  }

  // RatioVolume
  if (store.get("playback").ratioVolume) {
    ratioVolume.provide(ytmView);
    ratioVolume.enable();
    log.info("Integration enabled: Ratio volume");
  }

  // CompanionServer
  if (store.get("integrations").companionServerEnabled) {
    companionServer.provide(store, memoryStore, ytmView);
    companionServer.enable();
    log.info("Integration enabled: Companion server");
  }

  // DiscordPresence
  if (store.get("integrations").discordPresenceEnabled) {
    discordPresence.provide(memoryStore);
    discordPresence.enable();
    log.info("Integration enabled: Discord presence");
  }

  // NowPlayingNotifications
  if (store.get("general").showNotificationOnSongChange) {
    nowPlayingNotifications.enable();
    log.info("Integration enabled: Now playing notifications");
  }

  // CustomCSS
  if (store.get("appearance").customCSSEnabled) {
    customCss.provide(store, ytmView);
    customCss.enable();
    log.info("Integration enabled: Custom CSS");
  }
});

app.on("before-quit", () => {
  log.info("Application quitting\n\n");
  saveState();
});

app.on("open-url", (_, url) => {
  handleProtocol(url);
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    applicationQuitting = true;
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
